<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.korit.allways_back.mapper.ProductMapper">

    <!--
        상품 생성
        - product_tb에 새 상품 레코드 추가
        - is_system: 시스템 레시피(1) or 사용자 커스텀(0)
        - useGeneratedKeys: 자동 생성된 product_id를 Product 객체에 자동 매핑
    -->
    <insert id="insertProduct" parameterType="com.korit.allways_back.entity.Product"
            useGeneratedKeys="true" keyProperty="productId">
        INSERT INTO product_tb (is_system)
        VALUES (#{isSystem})
    </insert>

    <!--
        상품-아이템 연결
        - product_item_tb: 상품과 기본 아이템을 연결하는 중간 테이블
        - 예: productId=69 + itemId=5 (이탈리안 비엠티)
    -->
    <insert id="insertProductItem">
        INSERT INTO product_item_tb (product_id, item_id)
        VALUES (#{productId}, #{itemId})
    </insert>

    <!--
        상품-재료 연결
        - product_ingredient_tb: 상품과 선택한 재료들을 연결하는 중간 테이블
        - foreach로 여러 재료를 한 번에 INSERT
        - 예: productId=69 + ingredientIds=[103, 203, 301, 302, ...]
    -->
    <insert id="insertProductIngredients">
        INSERT INTO product_ingredient_tb (product_id, ingredient_id)
        VALUES
        <foreach collection="ingredientIds" item="ingredientId" separator=",">
            (#{productId}, #{ingredientId})
        </foreach>
    </insert>

    <!--
        기존 상품 찾기 (중복 체크)
        - 동일한 아이템 + 동일한 재료 조합이 이미 존재하는지 확인
        - 목적: 똑같은 조합의 상품을 중복 생성하지 않고 재사용

        로직:
        1. 재료가 없는 경우: itemId만 일치하고 재료가 없는 product 찾기
        2. 재료가 있는 경우:
           - itemId 일치
           - 재료 개수 일치 (ingredientCount)
           - 모든 재료 ID가 정확히 일치
           - 추가 재료가 없음
    -->
    <select id="findExistingProduct" resultType="Integer">
        <choose>
            <when test="ingredientIds == null or ingredientIds.isEmpty()">
                <!-- 재료가 없는 경우: 재료가 없는 product 찾기 -->
                SELECT p.product_id
                FROM product_tb p
                INNER JOIN product_item_tb pi ON p.product_id = pi.product_id
                WHERE pi.item_id = #{itemId}
                AND NOT EXISTS (
                SELECT 1
                FROM product_ingredient_tb ping
                WHERE ping.product_id = p.product_id
                )
                LIMIT 1
            </when>
            <otherwise>
                <!-- 재료가 있는 경우: 동일한 조합 찾기 -->
                SELECT p.product_id
                FROM product_tb p
                INNER JOIN product_item_tb pi ON p.product_id = pi.product_id
                WHERE pi.item_id = #{itemId}
                AND (
                SELECT COUNT(DISTINCT ping.ingredient_id)
                FROM product_ingredient_tb ping
                WHERE ping.product_id = p.product_id
                ) = #{ingredientCount}
                AND (
                SELECT SUM(CASE WHEN ping.ingredient_id IN
                <foreach collection="ingredientIds" item="id" open="(" close=")" separator=",">
                    #{id}
                </foreach>
                THEN 1 ELSE 0 END)
                FROM product_ingredient_tb ping
                WHERE ping.product_id = p.product_id
                ) = #{ingredientCount}
                AND NOT EXISTS (
                SELECT 1
                FROM product_ingredient_tb ping
                WHERE ping.product_id = p.product_id
                AND ping.ingredient_id NOT IN
                <foreach collection="ingredientIds" item="id" open="(" close=")" separator=",">
                    #{id}
                </foreach>
                )
                LIMIT 1
            </otherwise>
        </choose>
    </select>

    <!--
        상품 ID로 조회
        - product_tb에서 기본 상품 정보 조회
        - 반환: Product 객체 (productId, isSystem, createdAt)
    -->
    <select id="findById" resultType="com.korit.allways_back.entity.Product">
        SELECT
            product_id,
            is_system
        FROM
            product_tb
        WHERE
            product_id = #{productId}
    </select>

    <!--
        상품의 재료 목록 조회
        - product_ingredient_tb를 통해 해당 상품에 포함된 모든 재료 정보 조회
        - 반환: List<Ingredient> (ingredientId, ingredientName, price, categoryId, imgUrl)
    -->
    <select id="findIngredientsByProductId" resultType="com.korit.allways_back.entity.Ingredient">
        SELECT
            ing.ingredient_id,
            ing.ingredient_name,
            ing.price,
            ing.category_id,
            img.img_url AS imageUrl
        FROM
            ingredient_tb ing
            INNER JOIN product_ingredient_tb pi ON ing.ingredient_id = pi.ingredient_id
            LEFT JOIN image_tb img ON ing.image_id = img.image_id
        WHERE
            pi.product_id = #{productId}
    </select>

    <!--
        상품 가격 계산
        - 아이템 기본 가격 + 모든 재료 가격의 합
        - COALESCE: NULL 값을 0으로 처리
        - GROUP BY: 집계 함수(SUM) 사용 시 필요
    -->
    <select id="calculatePrice" resultType="Integer">
        SELECT
            COALESCE(i.price, 0) + COALESCE(SUM(ing.price), 0) AS totalPrice
        FROM
            product_tb p
                LEFT JOIN product_item_tb pi ON p.product_id = pi.product_id
                LEFT JOIN item_tb i ON pi.item_id = i.item_id
                LEFT JOIN product_ingredient_tb ping ON p.product_id = ping.product_id
                LEFT JOIN ingredient_tb ing ON ping.ingredient_id = ing.ingredient_id
        WHERE
            p.product_id = #{productId}
        GROUP BY
            p.product_id, i.price
    </select>

    <!--
        썹픽(Subway Pick) 조회
        - 특정 아이템의 시스템 레시피(is_system=1) 조회
        - DB에 미리 저장된 추천 레시피를 가져옴

        반환 데이터 (Map):
        - productId: 상품 ID
        - itemId: 아이템 ID
        - itemName: 아이템 이름
        - imageUrl: 이미지 URL
        - size: 사이즈 (15cm or 30cm)
        - totalPrice: 총 가격 (아이템 가격 + 재료 가격)

        예시:
        - itemId=5 (이탈리안 비엠티)
        - 시스템이 미리 정의한 레시피 조회
        - 바로 장바구니에 담을 수 있도록 모든 정보 반환
    -->
    <select id="findSubwayPickByItemId" resultType="map">
        SELECT
            p.product_id AS productId,
            i.item_id AS itemId,
            i.item_name AS itemName,
            i.size AS size,
            (i.price + COALESCE(SUM(ing.price), 0)) AS totalPrice
        FROM
            product_tb p
            INNER JOIN product_item_tb pi ON p.product_id = pi.product_id
            INNER JOIN item_tb i ON pi.item_id = i.item_id
            LEFT JOIN product_ingredient_tb ping ON p.product_id = ping.product_id
            LEFT JOIN ingredient_tb ing ON ping.ingredient_id = ing.ingredient_id
        WHERE
            p.is_system = 1
          AND i.item_id = #{itemId}
        GROUP BY
            p.product_id, i.item_id, i.item_name, i.size, i.price
            LIMIT 1
    </select>

</mapper>